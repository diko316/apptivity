{
  "name": "Apptivity",
  "tagline": "",
  "body": "# apptivity\r\n\r\n[![npm version](https://badge.fury.io/js/apptivity.png)](https://badge.fury.io/js/apptivity)\r\n\r\nAn activity workflow player that sequentially runs action, condition, fork, merge and prompt input actions.\r\n\r\nThis library has the following features.\r\n\r\n1. Convenient and rich [definition API](#usage_definition) to define and configure Workflow activities and actions. It helps developers to focus on overall activity logic before detailing them with their implementations.\r\n\r\n2. Flexible definition API allows splitting of Worfklow activity definition with their implementation, keeping files and directories of Workflow modules organized.\r\n\r\n3. Workflow activities and actions are more predictable as they each publish an [immutable](https://www.npmjs.com/package/immutable) state object containing unique state name, action name, request data, and response data per completed run of Activity action.\r\n\r\n4. Activity action supports asynchronous runs by supplying a `callback` function that returns Promise Object when defining Action implementations using [handler(callback:Function)](#ActivityAPI_handler) or [guard(callback:Function)](#ActivityAPI_guard) methods.\r\n\r\n5. Workflows' internal Finite State Machine can be exported into any custom JSON schema using [workflow.trasform(workflowName:String)](#transform).\r\n\r\n## Installation\r\n\r\nThis little library is packaged by npm. Source can be found in [github repository](https://github.com/diko316/apptivity)\r\n\r\n```sh\r\nnpm install apptivity --save\r\n```\r\n\r\n## Usage\r\n\r\n<a name=\"usage_definition\"></a>Create a Workflow activity and chain-configure actions with definition API.\r\n\r\n```javascript\r\nvar workflow = require('./index.js');\r\n\r\nworkflow.create(\"createUser\").\r\n\t\t\t// create action\r\n\t\t\taction(\"fetchFromBackend\").\r\n            \tdescribe(\"fetch something from the backend\",\r\n                \t\t\"or find something to populate the initial input data\",\r\n                        \"Remember: [describe], [guard] and [handler] is optional\").\r\n\t\t\t\tguard(function (input) {\r\n                \treturn Promise.resolve(input);\r\n                }).\r\n                handler(function (input) {\r\n                \treturn Ajax.requestAndReturnPromise(input);\r\n                }).\r\n\t\t\t// your last action\r\n\t\t\taction(\"renderAndExit\").\r\n            \tdescribe(\"Nothing special if no [handler]\").\r\n                handler(function (data) {\r\n                \treturn { name: \"whatever! this will be your last data\" };\r\n                });\r\n\r\n```\r\nRun the newly created Workflow activity and monitor state changes.\r\n\r\n```javascript\r\nworkflow(\"createUser\").\r\n\t// register event listener\r\n\ton(\"state-change\",\r\n        function (session, data) {\r\n        \tconsole.log(\"state: \", session.state === data);\r\n            console.log(\"yes! do something about this immutable [data]\");\r\n        }).\r\n\t// run the workflow\r\n    run({ name: \"first input\" });\r\n```\r\n\r\nListen to other running Workflow activity sessions' `state-change` event.\r\n\r\n```javascript\r\nvar stopListening = workflow.subscribe(\"createUser\", \"state-change\",\r\n\t\t\t\t\t\t\t\tfunction (session, data) {\r\n                                \tconsole.log(\"what should I do with this?\");\r\n                                });\r\n// I change my mind, I don't have to listen to \"createUser\" workflow's  \"state-change\" events\r\nstopListening();\r\n```\r\n> **Note**: You can subscribe to a workflow event anytime even if the workflow does not exist.\r\n\r\n\r\nExport the workflow into Finite State Machine configuration to create an instance of [javascript-state-machine](https://www.npmjs.com/package/javascript-state-machine).\r\n\r\n```javascript\r\nvar StateMachine = require(\"javascript-state-machine\");\r\n\r\nvar createUserStateMachine = StateMachine.create(\r\n\t\t\t\t\t\t\t\tworkflow.transform('createUser'));\r\n\r\n```\r\n\r\n\r\n## API\r\n\r\n### workflow(name:*String*):*sessionAPI*\r\n\r\nCreates session endpoint object from a registered workflow. The session object has the following convenience methods to handle most of the use-cases to manage a Workflow session:\r\n\r\n1. **sessionAPI.on**(**eventName**:*String|RegExp*, **handler**:*Function*):*sessionAPI*\r\nListen to events specific to the current session.\r\n\r\n2. **sessionAPI.un**(**eventName**:*String|RegExp*, **handler**:*Function*):*sessionAPI*\r\nRemoves event listener specific to the current session.\r\n\r\n3. **sessionAPI.purge**():*sessionAPI*\r\nRemoves all listeners of the current session.\r\n\r\n4. **sessionAPI.run**(**inputData**:*Mixed*, **context**:*Mixed*):*Promise*\r\nRuns the Workflow session with `inputData` parameter as initial request data. `context` parameter becomes `this` for all action guards and handlers. Default `context` is `global` for NodeJS or `window` for browsers.\r\n\r\n5. **sessionAPI.runOnce**(**inputData**:*Mixed*, **context**:*Mixed*):*Promise*\r\nRuns the Workflow session then destroys it when done.\r\n\r\n6. **sessionAPI.answer**(**value**:*Mixed*):*sessionAPI*\r\nReplies to prompts whenever the session runs an input action.\r\n\r\n7. **sessionAPI.get**():*Session*\r\nReturns the underlying *Session* instance that processes the Workflow.\r\n\r\n8. **sessionAPI.currentPrompt**():*String*\r\nReturns the currently active prompt *(input action name)* that is waiting for an answer. It can be answered by calling `sessionAPI.answer(Mixed) or session.asnwer(Mixed)`. Returns `false` if no prompt is waiting.\r\n\r\n9. **sessionAPI.currentState**():*[Immutable](http://facebook.github.io/immutable-js)*\r\nReturns [Immutable](https://facebook.github.io/immutable-js) or scalar value of the last process output.\r\n\r\n10. **sessionAPI.destroy**():*[Immutable](http://facebook.github.io/immutable-js)*\r\nDestroys the session and applies the necessary cleanup.\r\n\r\n### <a name=\"ActivityAPI\"></a> workflow.create(name:*String*):*Activity*\r\n\r\nCreates and registers workflow and returns Activity Definition Object in order to chain-define actions for it. The following are the actions that Activity can configure:\r\n\r\n1. **Activity.action**(**actionName**:*String*):*Activity*\r\nCreates action activity.\r\n\r\n2. **Activity.describe**(**description**:*String*, [**nextLine**:*String*]):*Activity*\r\nDescribes the last defined action.\r\n\r\n3. **Activity.guard**([**name**:*String*], **condition**:*String|Function*):*Activity*\r\nGuards the action from calling its handler. Defined handler and the rest of the actions will stop running when `condition` function returns a rejected Promise.\r\n>\t**Note:** `condition` parameter can also be a named [task](#namedTask) where it can be defined later.\r\n>\r\n>\tGuard `condition` runs with `input` and `session` arguments like the example below\r\n>\r\n>\t**handler**(**input**:*Mixed*, **session**:*Session*)\r\n\r\n ```javascript\r\nfunction guard(input, session) {\r\n\tvar context = this;\r\n    return Promise.reject(\"no entry!\");\r\n}\r\n```\r\n4. <a name=\"ActivityAPI_handler\"></a> **Activity.handler**(**handler**:*String|Function*):*Activity*\r\nDefines the callback of the action. The returned data or resolved Promise of the `handler` parameter becomes the response data of the current action and input data of the next action. If it is the last action, then it will become the reponse data of the whole activity.\r\n>\t**Note:** `handler` parameter can also be a named [task](#namedTask) where it can be defined later.\r\n>\r\n>\tHandler `handler` like guard `condition` runs with `input` and `session` arguments like the example below\r\n>\r\n>\t**handler**(**input**:*Mixed*, **session**:*Session*)))\r\n\r\n ```javascript\r\nfunction handler(input, session) {\r\n\tvar context = this;\r\n    return processInput(input);\r\n}\r\n```\r\n> **Warning**: Action must be defined first before chain-calling **describe()**, **guard()** and **handler()**.\r\n5. **Activity.input**(**actionName**:*String*):*Activity*\r\n\tCreates an action that waits for input before running the handler. Input actions are answered by calling `sessionAPI.answer(input:Mixed)` or `sesion.answer(input:Mixed)` replacing the action's request data with `input` argument.\r\n> **Warning!** Prompt is called after guard callback is executed.\r\n6. **Activity.end**():*Activity*\r\nCreates an action that abruptly ends the whole Workflow. The input for this action becomes the last output and state data of the Workflow session.\r\n\r\n7. **Activity.condition**(**activity**:*Activity*, [**other**:*Activity*, ...]):*Activity*\r\nRuns the first `activity` (and `other` parameters) that satisfies the guard condition of their first action.\r\n>\t**Warning!** Activities (`activity` and `other` parameters) having Guard condition in their first Action are evaluated first before falling back to other Activity without Guard condition in their first Action. Other activities after that will be ignored. So, there is no need to add two or more Activities without Guard condition in their first Action.\r\n>\tTreat activity having an unguarded first action as the only `else` block of the `if` and `else if` blocks.\r\n\r\n8. **Activity.fork**(**activity**:*Activity*, [**other**:*Activity*, ...]):*Activity*\r\nCreates an action that forks multiple process that simultaneously run all Activities (`activity` and `other` parameters) then merge all their output when done running.\r\nMerged output is an object with property names named with first Action of the forked Activities.\r\n> Example output object is `{ activity1: output, activity2: output}` when running the Forked Activities defined below:\r\n\r\n ```javascript\r\nworkflow.create(\"test-fork\").\r\n\tfork(\r\n\t\tworkflow.activity('a1').\r\n        \taction('activity1'),\r\n        workflow.activity('a2').\r\n        \taction('activity2')\r\n\t);\r\n```\r\n\r\n### workflow.exist(workflowName:*String*):*Boolean*\r\nFinds named workflow defined in `workflowName` parameter. Returns `true` if workflow exist or `false` otherwise.\r\n\r\n### workflow.subscribe([workflowName:*String*], eventName:*String|RegExp*, handler:Function):*Function*\r\n\r\nSubscribes all session events filtered by `workflowName` and `eventName` parameters. Then, returns a Function that can unsubscribe the event when called. `workflowName` parameter is optional and matches all workflow events when omitted.\r\n\r\nThe following are the events the session can broadcast with their callback parameters:\r\n\r\n1. **process-start** (**session**:*sessionAPI*, **stateData**:*[Immutable](http://facebook.github.io/immutable-js)*)\r\nEvent is broadcasted after running the first process for the first time. Usually the first action of the root workflow.\r\n\r\n2. **process-end** (**session**:*sessionAPI*, **stateData**:*[Immutable](http://facebook.github.io/immutable-js)*)\r\nEvent is broadcasted after running the last process. Usually the last action of the root workflow or if the workflow encounters an abrupt **end** action.\r\n\r\n3. **state-change** (**session**:*sessionAPI*, **stateData**:*[Immutable](http://facebook.github.io/immutable-js)*)\r\nEvent is broadcasted after action was completely processed.\r\n\r\n4. **prompt** (**session**:*sessionAPI*, **actionName**:*String*, **input**:*Mixed*)\r\nEvent is broadcasted after workflow encounters an **input** action and waiting for an answer.\r\n\r\n5. **answer** (**session**:*sessionAPI*, **actionName**:*String*, **input**:*Mixed*)\r\nEvent is broadcasted after workflow has answered a prompt from an **input** action by calling `session.answer(data)` or `sessionAPI.answer(data)`.\r\n\r\n6. **destroy** (**session**:*sessionAPI*)\r\nEvent is broadcasted after workflow session is destroyed. After this event, other session process will be killed and apply cleanup to the current workflow session.\r\n\r\n\r\n### workflow.activity(activityName:*String*):*Activity*\r\nCreates an [Activity](#ActivityAPI) instance used chain-define Actions and configurations. This is useful for defining Activity instances as parameters for `condition` and `fork` Action definition methods like the example below:\r\n\r\n ```javascript\r\nvar workflow = require(\"apptivity\");\r\n\r\nworkflow.create(\"myActivity\").\r\n\tcondition(\r\n    \tworkflow.activity(\"removeData\").\r\n        \tguard(\"data/checkpermission\").\r\n            handler(\"data/doRemove\"),\r\n\r\n\t\tworkflow.activity(\"showMessage\").\r\n        \thandler(\"data/showPermissionError\")\r\n    );\r\n```\r\n\r\n### <a name=\"namedTask\"></a>workflow.task(name:*String*, runner:*Function*):*workflowAPI*\r\n\r\nRegisters named tasks. Useful for assigning named task to action handlers and guards when splitting definition and implementation into separate files.\r\n\r\n>\t**Warning!** Named task can only be registered once. Registering task with the same name of an existing task will throw an exception from this method.\r\n\r\n\r\n### <a name=\"createTransformer\"></a>workflow.createTransformer(name:*String*, handler:*Function*):*workflowAPI*\r\n\r\nRegisters a named transformer to customize the exported Finite State Machine definition object. Named transformers are used as `transformer` parameter of the [workflow.transform(workflowName, transformer)](#transform) method.\r\n\r\n`handler` Function is the middleware used to customize **state name**, **node name**, **node definition object**, and **resulting FSM definition object** while building the exported object in [workflow.transform(workflowName, transformer)](#transform) method.\r\n\r\n`handler` Function's basic parameter is `handler(type:String, operation:Object, [others...])`. Other parameters excluding `operation` will vary according to `type` parameter.\r\n\r\n1. <a name=\"createTransformer_initialize\"></a>**handler**(**type**:`\"initialize\"`, **operation**:*Object*, **fsmName**:*String*, **configSettings**:*Object*):*Object*\r\nCustomizes the resulting FSM definition object by returning customization object. As for now, only `transitions:Object|Array` property in returned customization object is processed.\r\n\r\n2. **handler**(**type**:`\"state\"`, **operation**:*Object*, **stateName**:*String*, **stateType**:*String*):*String*\r\nCustomizes state name by returning new `stateName` String.\r\n`stateType` parameter determines the nature of the state. Possible values of `stateType` is **link**, **condition**, **fork**, and **end**.\r\n\r\n3. **handler**(**type**:`\"node\"`, **operation**:*Object*, **customStateName**:*String*, **proposedNode**:*Object*):*String*\r\nCustomizes node name by returning new `nodeName` String. Default node name is `Activity.prototype.id`.\r\nnode definition properties can be customized by replacing or adding properties in `proposedNode` object parameter.\r\n\r\n4. **handler**(**type**:`\"transition\"`, **operation**:*Object*, **sourceCustomStateName**:*String*, **customNodeName**:*Object*, **targetCustomStateName**):*Mixed*\r\nCustomizes transition definition.\r\nTransition is a row in State Table of a Finite State Machine which contains the following columns: `sourceCustomStateName`, `customNodeName` and `targetCustomStateName`.\r\nThere are two possible type of value to return depeding on the `transitions` property customized in [\"initialize\"](#createTransformer_initialize) phase.\r\n\r\n * **Array transitions** should return `Object` value representing the transition. Default transition value is `{ from: \"sourceState\", name: \"nodeName\", to: \"targetState\" }`. Returning non-object value will use the latter default value as transitions item.\r\n * **Object transitions** can return any value representing the target state. Default target state is the `targetCustomStateName` parameter. Returning `null` or `undefined` will use the default `targetCustomStateName` parameter.\r\n\r\n### <a name=\"trasform\"></a>workflow.transform(workflowName:*String*, [transformer:*String|Function*]):*workflowAPI*\r\n\r\nExports internal Finite State Machine of `workflowName` workflow using the optional `transformer` parameter middleware. The optional `transformer` parameter can be any of the descriptions below:\r\n\r\n * Providing String `transformer` parameter of `transform()` method will use the registered transformer defined with [workflow.createTransformer(name:*String*, handler:*Function*):*workflowAPI*](#createTransformer) method.\r\n * Providing Function `transformer` parameter of `transform()` method will directly use `transformer` parameter as customization callback middleware.\r\n * Leaving out `transformer` parameter will use `\"default\"` transformer which results into an exported Object used to create an instance of [javascript-state-machine](https://www.npmjs.com/package/javascript-state-machine) with `action` property containing node definitions.\r\n\r\n\r\n## License\r\n\r\n[MIT](https://opensource.org/licenses/MIT)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}